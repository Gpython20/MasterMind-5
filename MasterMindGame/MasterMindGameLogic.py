# coding=utf-8
import random
import unicodedata


from MasterMindGame.DTOs.GameStatDTO import GameStatDTO


class MasterMindGameLogic(object):
    """
    Class MasterMindGameLogic

    This class contains the logic and the operations adn rules for MasterMind game.
    This rules are based on board classic game.
    """
    limit_attempts = 12 #Max number off attempts to declatare game finished

    #The color list is composed of 10 elements to increase the possibilities of creating different combinations.
    # Due to the operation of the random this combination generates
    # more complex chains, including repetitions of colors in different positions.
    # It is a statistical fact
    colors = ['green', 'yellow', 'red', 'blue', 'violet', 'green', 'yellow', 'red', 'blue', 'violet']
    # ========================================
    #               Constructor
    # ========================================

    def __init__(self, previous_game_stats=None):
        if previous_game_stats:
            self.game_stat = previous_game_stats
        else:
            self.game_stat = GameStatDTO()
            self.game_stat.SetKeyPattern(self._generateNewSecretPattern())

    # ========================================
    #           Public Methods
    # ========================================

    def GetGameStats(self):
        """
        Return game stat
        :return: object type <GameStatDto>
        """
        return self.game_stat

    def PlayMove(self, player_move):
        """
        Check game stats and gets the result player move with the pattern created.
         This function wraps
        the private method _checkPlayerMove()

        :param player_move: List[]

        :return: object type <Class.GameStatDTO>
        """

        if not self.game_stat.GameIsFinished():
            if self._checkPlayerMove(player_move): # Process player move
                self.game_stat.AddPlayerMove(player_move) #Add move to history
                self.game_stat.IncrementAttemps()

                if self.game_stat.GetAttemps() >= self.limit_attempts:
                    self.game_stat.FinishGame() #Finish game

                return self.game_stat

            else:
                return None #One color selected not exist in game



    # ========================================
    #           Private Methods
    # ========================================
    def _generateNewSecretPattern(self):
        """
        From list color generates new random pattern game
        
        :return: List[]
        """
        secret_pattern = random.sample(self.colors, 4)
        return secret_pattern


    def _checkPlayerMove(self, player_move):
        """
         Check the play and get if the pattern of
         the player has coincidences with the pattern generated by the game

        :param player_move: List[]
        :return: Boolean True Complete operations / False not completed, color not exits
        """

        game_key_pattern = self.game_stat.GetKeyPattern()
        self.correct_color = ""
        self.guessed_color = ""

        if len(player_move) is 4:
            for i in range(4):
                player_color = player_move[i]
                if player_color not in self.colors:
                    return False

                if player_color == game_key_pattern[i]:
                    self.correct_color += "X"
                if player_color != game_key_pattern[i] and player_color in game_key_pattern:
                    self.guessed_color += "O"


            self.game_stat.AddMoveResult(self.correct_color + self.guessed_color)

            return True